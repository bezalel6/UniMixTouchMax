#include "MessageData.h"
#include <esp_log.h>

namespace Messaging {

// =============================================================================
// EXTERNAL MESSAGE METHODS
// =============================================================================

bool ExternalMessage::isSelfOriginated() const {
    return deviceId == Config::getDeviceId() ||
           originatingDeviceId == Config::getDeviceId();
}

bool ExternalMessage::requiresResponse() const {
    switch (messageType) {
        case MessageProtocol::ExternalMessageType::GET_STATUS:
        case MessageProtocol::ExternalMessageType::GET_ASSETS:
            return true;
        default:
            return false;
    }
}

// =============================================================================
// INTERNAL MESSAGE CONSTRUCTORS
// =============================================================================

InternalMessage::InternalMessage() {
    messageType = MessageProtocol::InternalMessageType::INVALID;
    timestamp = millis();
    priority = static_cast<uint8_t>(MessageProtocol::getInternalMessagePriority(messageType));
}

InternalMessage::InternalMessage(MessageProtocol::InternalMessageType type, const void* payload, size_t size)
    : messageType(type), dataSize(size) {
    timestamp = millis();
    priority = static_cast<uint8_t>(MessageProtocol::getInternalMessagePriority(type));

    if (payload && size > 0) {
        data.reset(new uint8_t[size]);
        memcpy(data.get(), payload, size);
    }
}

// =============================================================================
// ASSET RESPONSE DATA CONSTRUCTOR
// =============================================================================

AssetResponseData::AssetResponseData(const ExternalMessage& external) {
    requestId = external.requestId;
    deviceId = external.deviceId;
    timestamp = external.timestamp;

    // Extract asset-specific fields from parsed data
    processName = external.getString("processName", "");
    success = external.getBool("success", false);
    errorMessage = external.getString("errorMessage", "");
    assetDataBase64 = external.getString("assetData", "");

    if (external.hasField("metadata")) {
        // In ArduinoJson v7, use direct access
        if (external.isObject("metadata")) {
            // Direct access to the fields
            width = external.parsedData["metadata"]["width"].as<int>();
            height = external.parsedData["metadata"]["height"].as<int>();
            format = external.parsedData["metadata"]["format"].as<String>();
        }
    }
}
// =============================================================================
// MESSAGE FACTORY IMPLEMENTATIONS - EXTERNAL MESSAGES ONLY
// =============================================================================
// Internal message factories are now generated by macros in MessageData.h

ExternalMessage MessageFactory::createStatusRequest(const String& deviceId) {
    String devId = deviceId.isEmpty() ? Config::getDeviceId() : deviceId;
    ExternalMessage message(MessageProtocol::ExternalMessageType::GET_STATUS,
                           Config::generateRequestId(), devId);
    return message;
}

ExternalMessage MessageFactory::createAssetRequest(const String& processName, const String& deviceId) {
    String devId = deviceId.isEmpty() ? Config::getDeviceId() : deviceId;
    ExternalMessage message(MessageProtocol::ExternalMessageType::GET_ASSETS,
                           Config::generateRequestId(), devId);

    // Add process name to parsed data
    message.parsedData["processName"] = processName;
    return message;
}

// =============================================================================
// MESSAGE PARSER IMPLEMENTATIONS
// =============================================================================

ParseResult<MessageProtocol::ExternalMessageType> MessageParser::parseExternalMessageType(const String& jsonPayload) {
    const char* TAG = "MessageParser";

    if (jsonPayload.isEmpty()) {
        return ParseResult<MessageProtocol::ExternalMessageType>::createError("Empty JSON payload");
    }

    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, jsonPayload);

    if (error) {
        String errorMsg = "JSON deserialization failed: " + String(error.c_str());
        ESP_LOGW(TAG, "%s", errorMsg.c_str());
        return ParseResult<MessageProtocol::ExternalMessageType>::createError(errorMsg);
    }

    JsonObject obj = doc.as<JsonObject>();
    if (!obj[MessageProtocol::JsonFields::MESSAGE_TYPE].is<int>()) {
        return ParseResult<MessageProtocol::ExternalMessageType>::createError("Missing messageType field");
    }

    int typeValue = obj[MessageProtocol::JsonFields::MESSAGE_TYPE];
    auto messageType = static_cast<MessageProtocol::ExternalMessageType>(typeValue);

    if (!MessageProtocol::isValidExternalMessageType(messageType)) {
        return ParseResult<MessageProtocol::ExternalMessageType>::createError("Invalid messageType value");
    }

    return ParseResult<MessageProtocol::ExternalMessageType>::createSuccess(messageType);
}

ParseResult<ExternalMessage> MessageParser::parseExternalMessage(const String& jsonPayload) {
    const char* TAG = "MessageParser";
    using namespace MessageProtocol::JsonFields;

    if (jsonPayload.isEmpty()) {
        return ParseResult<ExternalMessage>::createError("Empty JSON payload");
    }

    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, jsonPayload);

    if (error) {
        String errorMsg = "JSON deserialization failed: " + String(error.c_str());
        ESP_LOGW(TAG, "%s", errorMsg.c_str());
        return ParseResult<ExternalMessage>::createError(errorMsg);
    }

    JsonObject obj = doc.as<JsonObject>();

    // Parse message type
    if (!obj[MESSAGE_TYPE].is<int>()) {
        return ParseResult<ExternalMessage>::createError("Missing messageType field");
    }

    int typeValue = obj[MESSAGE_TYPE];
    auto messageType = static_cast<MessageProtocol::ExternalMessageType>(typeValue);

    if (!MessageProtocol::isValidExternalMessageType(messageType)) {
        return ParseResult<ExternalMessage>::createError("Invalid messageType value");
    }

    // Parse other fields
    String requestId = obj[REQUEST_ID].as<String>();
    String deviceId = obj[DEVICE_ID].as<String>();
    String originatingDeviceId = obj[ORIGINATING_DEVICE_ID].as<String>();
    unsigned long timestamp = obj[TIMESTAMP];

    if (timestamp == 0) {
        timestamp = millis();
    }

    // Create message
    ExternalMessage message(messageType, requestId, deviceId);
    message.originatingDeviceId = originatingDeviceId;
    message.timestamp = timestamp;
    message.validated = true;

    // Copy parsed data
    message.parsedData.set(obj);

    ESP_LOGD(TAG, "Successfully parsed external message: type=%d, deviceId=%s",
             static_cast<int>(messageType), deviceId.c_str());

    return ParseResult<ExternalMessage>::createSuccess(message);
}

bool MessageParser::shouldIgnoreMessage(const ExternalMessage& message, const String& myDeviceId) {
    // Ignore invalid messages
    if (message.messageType == MessageProtocol::ExternalMessageType::INVALID) {
        return true;
    }

    // Ignore self-originated messages
    if (message.deviceId == myDeviceId) {
        return true;
    }

    // Ignore messages from our own device ID in originatingDeviceId
    if (!message.originatingDeviceId.isEmpty() && message.originatingDeviceId == myDeviceId) {
        return true;
    }

    return false;
}

ParseResult<AudioStatusData> MessageParser::parseAudioStatusData(const ExternalMessage& message) {
    const char* TAG = "MessageParser";
    using namespace MessageProtocol::JsonFields;

    AudioStatusData data;

    if (message.messageType != MessageProtocol::ExternalMessageType::STATUS_UPDATE &&
        message.messageType != MessageProtocol::ExternalMessageType::STATUS_MESSAGE) {
        return ParseResult<AudioStatusData>::createError("Invalid message type for audio status");
    }

    try {
        // Extract sessions
        if (message.parsedData[SESSIONS].is<JsonArray>()) {
            // Workaround for ArduinoJson v7 false positive: use size-based iteration
            auto sessionsArray = message.parsedData[SESSIONS];
            for (size_t i = 0; i < sessionsArray.size(); i++) {
                auto sessionVariant = sessionsArray[i];
                if (sessionVariant.is<JsonObject>()) {
                    // Direct field access without storing JsonObject reference
                    SessionStatusData session;
                    session.processId = sessionVariant[PROCESS_ID];
                    session.processName = sessionVariant[PROCESS_NAME].as<String>();
                    session.displayName = sessionVariant[DISPLAY_NAME].as<String>();
                    session.volume = sessionVariant[VOLUME];
                    session.isMuted = sessionVariant[IS_MUTED];
                    session.state = sessionVariant[STATE].as<String>();

                    data.sessions.push_back(session);
                }
            }
        }

        // Extract default device
        if (message.parsedData[DEFAULT_DEVICE].is<JsonObject>()) {
            // Use direct field access instead of storing JsonObject reference
            data.defaultDevice.friendlyName = message.parsedData[DEFAULT_DEVICE][FRIENDLY_NAME].as<String>();
            data.defaultDevice.volume = message.parsedData[DEFAULT_DEVICE][VOLUME];
            data.defaultDevice.isMuted = message.parsedData[DEFAULT_DEVICE][IS_MUTED];
            data.defaultDevice.dataFlow = message.parsedData[DEFAULT_DEVICE][DATA_FLOW].as<String>();
            data.defaultDevice.deviceRole = message.parsedData[DEFAULT_DEVICE][DEVICE_ROLE].as<String>();
            data.hasDefaultDevice = true;
        }

        // Extract metadata
        data.timestamp = message.timestamp;
        data.reason = message.parsedData[REASON].as<String>();
        data.originatingDeviceId = message.parsedData[ORIGINATING_DEVICE_ID].as<String>();
        data.originatingRequestId = message.parsedData[ORIGINATING_REQUEST_ID].as<String>();
        data.activeSessionCount = message.parsedData[ACTIVE_SESSION_COUNT];

    } catch (const std::exception& e) {
        String errorMsg = "Error parsing audio status data: " + String(e.what());
        ESP_LOGE(TAG, "%s", errorMsg.c_str());
        return ParseResult<AudioStatusData>::createError(errorMsg);
    }

    return ParseResult<AudioStatusData>::createSuccess(data);
}

ParseResult<AssetResponseData> MessageParser::parseAssetResponseData(const ExternalMessage& message) {
    const char* TAG = "MessageParser";

    if (message.messageType != MessageProtocol::ExternalMessageType::ASSET_RESPONSE) {
        return ParseResult<AssetResponseData>::createError("Invalid message type for asset response");
    }

    try {
        AssetResponseData data(message);
        return ParseResult<AssetResponseData>::createSuccess(data);
    } catch (const std::exception& e) {
        String errorMsg = "Error parsing asset response data: " + String(e.what());
        ESP_LOGE(TAG, "%s", errorMsg.c_str());
        return ParseResult<AssetResponseData>::createError(errorMsg);
    }
}

// =============================================================================
// MESSAGE SERIALIZER IMPLEMENTATIONS
// ===========================================================================
//



ParseResult<String> MessageSerializer::serializeInternalMessage(const InternalMessage& message) {
    const char* TAG = "MessageSerializer";

    try {
        JsonDocument doc;

        doc["messageType"] = static_cast<int>(message.messageType);
        doc["timestamp"] = message.timestamp;
        doc["priority"] = message.priority;
        doc["dataSize"] = message.dataSize;
        doc["requiresResponse"] = message.requiresResponse;

        String jsonString;
        serializeJson(doc, jsonString);

        return ParseResult<String>::createSuccess(jsonString);

    } catch (const std::exception& e) {
        String errorMsg = "Error serializing internal message: " + String(e.what());
        ESP_LOGE(TAG, "%s", errorMsg.c_str());
        return ParseResult<String>::createError(errorMsg);
    }
}

ParseResult<String> MessageSerializer::createStatusResponse(const AudioStatusData& data) {
    const char* TAG = "MessageSerializer";
    using namespace MessageProtocol::JsonFields;

    try {
        JsonDocument doc;

        doc[MESSAGE_TYPE] = static_cast<int>(MessageProtocol::ExternalMessageType::STATUS_MESSAGE);
        doc[DEVICE_ID] = Config::getDeviceId();
        doc[TIMESTAMP] = data.timestamp;
        doc[ACTIVE_SESSION_COUNT] = data.activeSessionCount;

        if (!data.reason.isEmpty()) {
            doc[REASON] = data.reason;
        }

        if (!data.originatingDeviceId.isEmpty()) {
            doc[ORIGINATING_DEVICE_ID] = data.originatingDeviceId;
        }

        if (!data.originatingRequestId.isEmpty()) {
            doc[ORIGINATING_REQUEST_ID] = data.originatingRequestId;
        }

        // Serialize sessions
        JsonArray sessionsArray = doc[SESSIONS].to<JsonArray>();
        for (const auto& session : data.sessions) {
            JsonObject sessionObj = sessionsArray.add<JsonObject>();
            sessionObj[PROCESS_ID] = session.processId;
            sessionObj[PROCESS_NAME] = session.processName;
            sessionObj[DISPLAY_NAME] = session.displayName;
            sessionObj[VOLUME] = session.volume;
            sessionObj[IS_MUTED] = session.isMuted;
            sessionObj[STATE] = session.state;
        }

        // Serialize default device
        if (data.hasDefaultDevice) {
            JsonObject defaultObj = doc[DEFAULT_DEVICE].to<JsonObject>();
            defaultObj[FRIENDLY_NAME] = data.defaultDevice.friendlyName;
            defaultObj[VOLUME] = data.defaultDevice.volume;
            defaultObj[IS_MUTED] = data.defaultDevice.isMuted;
            defaultObj[DATA_FLOW] = data.defaultDevice.dataFlow;
            defaultObj[DEVICE_ROLE] = data.defaultDevice.deviceRole;
        }

        String jsonString;
        serializeJson(doc, jsonString);

        return ParseResult<String>::createSuccess(jsonString);

    } catch (const std::exception& e) {
        String errorMsg = "Error creating status response: " + String(e.what());
        ESP_LOGE(TAG, "%s", errorMsg.c_str());
        return ParseResult<String>::createError(errorMsg);
    }
}

ParseResult<String> MessageSerializer::createAssetRequest(const String& processName, const String& deviceId) {
    const char* TAG = "MessageSerializer";

    try {
        JsonDocument doc;

        String devId = deviceId.isEmpty() ? Config::getDeviceId() : deviceId;

        doc[MessageProtocol::JsonFields::MESSAGE_TYPE] = static_cast<int>(MessageProtocol::ExternalMessageType::GET_ASSETS);
        doc[MessageProtocol::JsonFields::REQUEST_ID] = Config::generateRequestId();
        doc[MessageProtocol::JsonFields::DEVICE_ID] = devId;
        doc[MessageProtocol::JsonFields::TIMESTAMP] = millis();
        doc["processName"] = processName;

        String jsonString;
        serializeJson(doc, jsonString);

        return ParseResult<String>::createSuccess(jsonString);

    } catch (const std::exception& e) {
        String errorMsg = "Error creating asset request: " + String(e.what());
        ESP_LOGE(TAG, "%s", errorMsg.c_str());
        return ParseResult<String>::createError(errorMsg);
    }
}

// =============================================================================
// MESSAGE CONVERTER IMPLEMENTATIONS
// =============================================================================

std::vector<InternalMessage> MessageConverter::externalToInternal(const ExternalMessage& external) {
    std::vector<InternalMessage> internalMessages;

    switch (external.messageType) {
        case MessageProtocol::ExternalMessageType::STATUS_UPDATE:
        case MessageProtocol::ExternalMessageType::STATUS_MESSAGE: {
            auto parseResult = MessageParser::parseAudioStatusData(external);
            if (parseResult.isValid()) {
                InternalMessage msg(MessageProtocol::InternalMessageType::AUDIO_STATE_UPDATE,
                                   &parseResult.getValue(), sizeof(AudioStatusData));
                internalMessages.push_back(msg);
            }
            break;
        }

        case MessageProtocol::ExternalMessageType::ASSET_RESPONSE: {
            auto parseResult = MessageParser::parseAssetResponseData(external);
            if (parseResult.isValid()) {
                InternalMessage msg(MessageProtocol::InternalMessageType::ASSET_RESPONSE,
                                   &parseResult.getValue(), sizeof(AssetResponseData));
                internalMessages.push_back(msg);
            }
            break;
        }

        default:
            // For other message types, create generic internal message
            break;
    }

    return internalMessages;
}

ExternalMessage MessageConverter::internalToExternal(const InternalMessage& internal) {
    ExternalMessage external;

    switch (internal.messageType) {
        case MessageProtocol::InternalMessageType::AUDIO_STATE_UPDATE: {
            external.messageType = MessageProtocol::ExternalMessageType::STATUS_MESSAGE;
            external.requestId = Config::generateRequestId();
            external.deviceId = Config::getDeviceId();
            external.timestamp = internal.timestamp;
            break;
        }

        default:
            external.messageType = MessageProtocol::ExternalMessageType::INVALID;
            break;
    }

    return external;
}

} // namespace Messaging
